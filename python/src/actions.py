"""
Action generation utilities for creating BrowserAction objects.

This module provides factory functions for creating different types of browser actions
(click, type, navigate, scroll, etc.). These functions integrate with LLMDataGenerator
to produce realistic element selectors, text values, and other action parameters.

All functions follow a consistent pattern:
- Accept timestamp, URL, page_title, session/tab IDs, and action_id
- Optionally use LLM generator for realistic data
- Return a fully-formed BrowserAction object
"""

import random
from typing import Dict, List, Optional
from src.schema import BrowserAction
from src.utils import (
    generate_id, get_timestamp_offset,
    get_decision_time, calculate_typing_time,
    get_typing_speed_wpm, get_reading_time
)
from src.llm_generator import LLMDataGenerator


def create_navigate_action(
    timestamp: float,
    url: str,
    page_title: str,
    session_id: str,
    tab_id: str,
    action_id: str,
    is_intentional: bool = True,
    llm_generator: Optional[LLMDataGenerator] = None
) -> BrowserAction:
    """
    Create a navigate action (URL navigation).
    
    Represents a user navigating to a new URL, either by typing in the address bar,
    clicking a bookmark, or using browser navigation controls.
    
    Args:
        timestamp: Unix timestamp in milliseconds when navigation occurred
        url: Target URL to navigate to
        page_title: Title of the destination page
        session_id: Browser session identifier
        tab_id: Browser tab identifier
        action_id: Unique identifier for this action
        is_intentional: Whether navigation was goal-directed (default: True)
        llm_generator: Optional LLM generator (not used for navigate actions)
    
    Returns:
        BrowserAction with action_type='navigate'
    
    Note:
        Navigate actions don't have target elements, so element_type and
        element_selector are set to empty strings.
    """
    return BrowserAction(
        timestamp=timestamp,
        action_type='navigate',
        action_id=action_id,
        element_type='',
        element_selector='',
        url=url,
        page_title=page_title,
        session_id=session_id,
        tab_id=tab_id,
        is_intentional=is_intentional,
        user_intent='navigate' if is_intentional else None
    )


def create_click_action(
    timestamp: float,
    element_type: str,
    url: str,
    page_title: str,
    session_id: str,
    tab_id: str,
    action_id: str,
    workflow_type: str,
    context: str,
    user_intent: Optional[str] = None,
    is_intentional: bool = True,
    llm_generator: Optional[LLMDataGenerator] = None,
    selector: Optional[str] = None,
    element_text: Optional[str] = None,
    element_id: Optional[str] = None,
    element_classes: Optional[List[str]] = None
) -> BrowserAction:
    """
    Create a click action with LLM-generated element data.
    
    Represents a user clicking on an element (button, link, checkbox, etc.).
    If an LLM generator is provided and no selector is given, the LLM will
    generate realistic element data including selector, text, ID, and classes.
    
    Args:
        timestamp: Unix timestamp in milliseconds when click occurred
        element_type: HTML element type (e.g., 'button', 'link', 'checkbox')
        url: Current page URL
        page_title: Current page title
        session_id: Browser session identifier
        tab_id: Browser tab identifier
        action_id: Unique identifier for this action
        workflow_type: Type of workflow (e.g., 'e_commerce', 'form_filling')
        context: Description of what user is clicking (for LLM context)
        user_intent: Semantic intent (e.g., 'add_to_cart', 'search')
        is_intentional: Whether click was goal-directed (default: True)
        llm_generator: Optional LLM generator for realistic element data
        selector: CSS selector (if None and llm_generator provided, will be generated)
        element_text: Visible text of element (optional, may be generated by LLM)
        element_id: HTML id attribute (optional, may be generated by LLM)
        element_classes: CSS classes list (optional, may be generated by LLM)
    
    Returns:
        BrowserAction with action_type='click' and element_visible/clickable=True
    
    Note:
        If neither selector nor llm_generator is provided, a fallback selector
        will be generated using element_type and a random ID.
    """
    # Use LLM to generate element data if generator provided
    if llm_generator and not selector:
        element_data = llm_generator.generate_element_data(
            element_type=element_type,
            context=context,
            workflow_type=workflow_type
        )
        selector = element_data["selector"]
        element_text = element_data.get("element_text") or element_text
        element_id = element_data.get("element_id") or element_id
        element_classes = element_data.get("element_classes") or element_classes
    elif not selector:
        # Fallback if no LLM generator and no selector provided
        selector = f"#{element_type}-{generate_id('el')}"
    
    return BrowserAction(
        timestamp=timestamp,
        action_type='click',
        action_id=action_id,
        element_type=element_type,
        element_selector=selector,
        element_text=element_text,
        element_id=element_id,
        element_classes=element_classes,
        url=url,
        page_title=page_title,
        session_id=session_id,
        tab_id=tab_id,
        is_intentional=is_intentional,
        user_intent=user_intent,
        element_visible=True,
        element_clickable=True
    )


def create_type_action(
    timestamp: float,
    url: str,
    page_title: str,
    session_id: str,
    tab_id: str,
    action_id: str,
    workflow_type: str,
    field_type: str,
    context: Optional[str] = None,
    user_intent: Optional[str] = None,
    is_intentional: bool = True,
    llm_generator: Optional[LLMDataGenerator] = None,
    selector: Optional[str] = None,
    value: Optional[str] = None,
    element_id: Optional[str] = None
) -> BrowserAction:
    """
    Create a type action (text input) with LLM-generated data.
    
    Represents a user typing text into an input field. The LLM can generate
    realistic input values (e.g., email addresses, names, search queries)
    and element selectors based on the field type and workflow context.
    
    Args:
        timestamp: Unix timestamp in milliseconds when typing occurred
        url: Current page URL
        page_title: Current page title
        session_id: Browser session identifier
        tab_id: Browser tab identifier
        action_id: Unique identifier for this action
        workflow_type: Type of workflow (e.g., 'e_commerce', 'form_filling')
        field_type: Type of input field (e.g., 'email', 'search_query', 'name')
        context: Optional description of the input field context
        user_intent: Semantic intent (e.g., 'submit_form', 'search')
        is_intentional: Whether typing was goal-directed (default: True)
        llm_generator: Optional LLM generator for realistic values and selectors
        selector: CSS selector (if None and llm_generator provided, will be generated)
        value: Text value to type (if None and llm_generator provided, will be generated)
        element_id: HTML id attribute (optional, may be generated by LLM)
    
    Returns:
        BrowserAction with action_type='type', element_type='input', and value set
    
    Note:
        If no value is provided and no LLM generator is available, a fallback
        value like 'test_{field_type}' will be used.
    """
    # Use LLM to generate input value and element data
    if llm_generator:
        if not value:
            value = llm_generator.generate_text_input_value(
                field_type=field_type,
                workflow_type=workflow_type,
                context=context
            )
        if not selector:
            element_data = llm_generator.generate_element_data(
                element_type='input',
                context=f"{field_type} input field",
                workflow_type=workflow_type
            )
            selector = element_data["selector"]
            element_id = element_data.get("element_id") or element_id
    elif not selector:
        selector = f"input[name='{field_type}']"
    if not value:
        value = f"test_{field_type}"
    return BrowserAction(
        timestamp=timestamp,
        action_type='type',
        action_id=action_id,
        element_type='input',
        element_selector=selector,
        value=value,
        element_id=element_id,
        url=url,
        page_title=page_title,
        session_id=session_id,
        tab_id=tab_id,
        is_intentional=is_intentional,
        user_intent=user_intent,
        element_visible=True,
        element_clickable=True
    )


def create_scroll_action(
    timestamp: float,
    url: str,
    page_title: str,
    session_id: str,
    tab_id: str,
    action_id: str,
    coordinates: Dict[str, int],
    is_intentional: bool = True
) -> BrowserAction:
    """
    Create a scroll action.
    
    Represents a user scrolling the page. The coordinates dict should contain
    'x' and 'y' keys indicating the scroll position.
    
    Args:
        timestamp: Unix timestamp in milliseconds when scroll occurred
        url: Current page URL
        page_title: Current page title
        session_id: Browser session identifier
        tab_id: Browser tab identifier
        action_id: Unique identifier for this action
        coordinates: Dict with 'x' and 'y' keys for scroll position
        is_intentional: Whether scroll was goal-directed (default: True)
    
    Returns:
        BrowserAction with action_type='scroll', element_type='body',
        and element_clickable=False (body element is not clickable)
    """
    return BrowserAction(
        timestamp=timestamp,
        action_type='scroll',
        action_id=action_id,
        element_type='body',
        element_selector='body',
        coordinates=coordinates,
        url=url,
        page_title=page_title,
        session_id=session_id,
        tab_id=tab_id,
        is_intentional=is_intentional,
        element_visible=True,
        element_clickable=False
    )


def create_select_action(
    timestamp: float,
    url: str,
    page_title: str,
    session_id: str,
    tab_id: str,
    action_id: str,
    workflow_type: str,
    context: str,
    option_index: int,
    user_intent: Optional[str] = None,
    is_intentional: bool = True,
    llm_generator: Optional[LLMDataGenerator] = None,
    selector: Optional[str] = None,
    element_id: Optional[str] = None
) -> BrowserAction:
    """
    Create a select action (dropdown selection) with LLM-generated element data.
    
    Represents a user selecting an option from a dropdown/select element.
    The option_index indicates which option was selected (0-based index).
    
    Args:
        timestamp: Unix timestamp in milliseconds when selection occurred
        url: Current page URL
        page_title: Current page title
        session_id: Browser session identifier
        tab_id: Browser tab identifier
        action_id: Unique identifier for this action
        workflow_type: Type of workflow (e.g., 'e_commerce', 'form_filling')
        context: Description of what is being selected (for LLM context)
        option_index: Zero-based index of the selected option
        user_intent: Semantic intent (e.g., 'filter_results', 'select_shipping')
        is_intentional: Whether selection was goal-directed (default: True)
        llm_generator: Optional LLM generator for realistic element selectors
        selector: CSS selector (if None and llm_generator provided, will be generated)
        element_id: HTML id attribute (optional, may be generated by LLM)
    
    Returns:
        BrowserAction with action_type='select', element_type='select',
        and option_index set
    """
    if llm_generator and not selector:
        element_data = llm_generator.generate_element_data(
            element_type='select',
            context=context,
            workflow_type=workflow_type
        )
        selector = element_data["selector"]
        element_id = element_data.get("element_id") or element_id
    elif not selector:
        selector = f"select[name='{context.lower().replace(' ', '_')}']"
    
    return BrowserAction(
        timestamp=timestamp,
        action_type='select',
        action_id=action_id,
        element_type='select',
        element_selector=selector,
        option_index=option_index,
        element_id=element_id,
        url=url,
        page_title=page_title,
        session_id=session_id,
        tab_id=tab_id,
        is_intentional=is_intentional,
        user_intent=user_intent,
        element_visible=True,
        element_clickable=True
    )


def create_submit_action(
    timestamp: float,
    url: str,
    page_title: str,
    session_id: str,
    tab_id: str,
    action_id: str,
    user_intent: Optional[str] = None,
    is_intentional: bool = True
) -> BrowserAction:
    """
    Create a submit action (form submission).
    
    Represents a user submitting a form. This is semantically different from
    clicking a submit button - it represents the form submission event itself.
    
    Args:
        timestamp: Unix timestamp in milliseconds when submission occurred
        url: Current page URL
        page_title: Current page title
        session_id: Browser session identifier
        tab_id: Browser tab identifier
        action_id: Unique identifier for this action
        user_intent: Semantic intent (e.g., 'submit_form', 'create_account')
        is_intentional: Whether submission was goal-directed (default: True)
    
    Returns:
        BrowserAction with action_type='submit', element_type='form'
    """
    return BrowserAction(
        timestamp=timestamp,
        action_type='submit',
        action_id=action_id,
        element_type='form',
        element_selector='form',
        url=url,
        page_title=page_title,
        session_id=session_id,
        tab_id=tab_id,
        is_intentional=is_intentional,
        user_intent=user_intent,
        element_visible=True,
        element_clickable=True
    )


def create_wait_action(
    timestamp: float,
    url: str,
    page_title: str,
    session_id: str,
    tab_id: str,
    action_id: str,
    duration: float,
    is_intentional: bool = True
) -> BrowserAction:
    """
    Create a wait action (intentional delay).
    
    Represents an intentional wait period, such as waiting for a page to load,
    waiting for an animation to complete, or a user reading pause.
    
    Args:
        timestamp: Unix timestamp in milliseconds when wait started
        url: Current page URL
        page_title: Current page title
        session_id: Browser session identifier
        tab_id: Browser tab identifier
        action_id: Unique identifier for this action
        duration: Wait duration in seconds
        is_intentional: Whether wait was intentional (default: True)
    
    Returns:
        BrowserAction with action_type='wait' and element_clickable=False
    """
    return BrowserAction(
        timestamp=timestamp,
        action_type='wait',
        action_id=action_id,
        element_type='',
        element_selector='',
        url=url,
        page_title=page_title,
        session_id=session_id,
        tab_id=tab_id,
        is_intentional=is_intentional,
        element_visible=True,
        element_clickable=False
    )

